{
  "hash": "378772dbc2e82a4d7e156618a6068ced",
  "result": {
    "engine": "knitr",
    "markdown": "# Assignment 2: The Economics Simulation\n\nDisclosure: A lot of this assignment was created by consulting ChatGPT, especially during the (as of yet) unsuccessful attempt to not have the endless warning \"NAs produziert\" as the final output\n\n___\n\nPreliminary definitions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 100 # default size of the population\nMU <- 100 # default mean of the population\n\npopulation <- rnorm(N, mean=MU, sd=MU/5)\n\npercentile <- function(p, x) {\n  return(quantile(x, probs = p / 100, na.rm = TRUE))\n}\n```\n:::\n\n\n\n\nGini Coefficient\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  y <- sort(y)\n  n <- length(y)\n  numer <- sum((2 * (1:n) - n - 1) * y)\n  denom <- n * sum(y)\n  gini_coeff <- numer / denom\n  return(gini_coeff)\n}\n```\n:::\n\n\n\n\nPlotting a histogram of the population\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(population)\n```\n\n::: {.cell-output-display}\n![](indexhw2_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nTransaction function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(a, b) {\n  pot <- a + b\n  share <- runif(1, min = 0, max = pot)\n  return(c(max(0, share), max(0, pot - share)))  # Ensure values are non-negative\n}\n\nrandom_split(100, 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  25.70705 174.29295\n```\n\n\n:::\n:::\n\n\n\n\nInteraction function \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(N) { \n  return(sample(0:(N-1),2)) \n  }\n\nanyone(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n:::\n\n\n\n\nSimulation function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep <- function(population, transaction = random_split, interaction = anyone) {\n  indices <- interaction(length(population))\n  i <- indices[1]\n  j <- indices[2]\n  new_values <- transaction(population[i], population[j])\n  population[i] <- new_values[1]\n  population[j] <- new_values[2]\n  return(population)\n}\n\nsimulate <- function(population, T, step_function = step, transaction = random_split, interaction = anyone) {\n  snapshots <- list()\n  snapshots[[1]] <- population\n  for(t in 1:T) {\n    population <- step_function(population, transaction, interaction)\n    snapshots[[t + 1]] <- population\n  }\n  return(snapshots)\n}\n```\n:::\n\n\n\n\nVisualisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Function to calculate percentiles\npercent <- function(pct, items) {\n  return(quantile(items, probs = pct / 100))\n}\n\n# Function to simulate and display results\nshow <- function(population, k = 40, percentiles = c(1, 10, 50, 90, 99), transaction = random_split, interaction = anyone, step_function = step) {\n  N <- length(population)\n  start <- population\n  T <- k * N\n  \n  # Run the simulation\n  results <- lapply(seq_len(T), function(t) {\n    pop <- simulate(population, T, step_function, transaction, interaction)[[t]]\n    list(t = t, pop = sort(pop))  # Sort the population at each step\n  })\n  \n  # Filter results to only include the relevant time steps\n  results <- results[seq(1, T, by = N / 10)]  # Print every N/10 steps\n  \n  # Printout\n  cat(sprintf(\"   t    Gini   stdev  %s\\n\", paste(sprintf(\"%3d%%\", percentiles), collapse = \" \")))\n  cat(sprintf(\"------- ----  -----  %s\\n\", paste(rep(\"----\", length(percentiles)), collapse = \" \")))\n  \n  for (res in results) {\n    t <- res$t\n    pop <- res$pop\n    gini_val <- gini(pop)\n    stdev_val <- sd(pop)\n    perc_vals <- sapply(percentiles, function(pct) percent(pct, pop))\n    \n    if (t %% (k * N / 10) == 0) {\n      cat(sprintf(\"%7d %.2f  %5.1f  %s\\n\", t, gini_val, stdev_val, paste(sprintf(\"%4.0f\", perc_vals), collapse = \" \")))\n    }\n  }\n  \n  # Plot Percentile Plots\n  times <- sapply(results, function(res) res$t)\n  data_list <- lapply(percentiles, function(pct) {\n    sapply(results, function(res) percent(pct, res$pop))\n  })\n  \n  percentile_plot <- ggplot() + theme_minimal() +\n    labs(x = 'Time', y = 'Wealth', title = paste(percentiles, 'Percentile Plots', sep = \"/\")) +\n    geom_line(aes(x = times, y = data_list[[1]], color = as.factor(percentiles[1])), size = 1) +\n    geom_line(aes(x = times, y = data_list[[2]], color = as.factor(percentiles[2])), size = 1) +\n    geom_line(aes(x = times, y = data_list[[3]], color = as.factor(percentiles[3])), size = 1) +\n    geom_line(aes(x = times, y = data_list[[4]], color = as.factor(percentiles[4])), size = 1) +\n    geom_line(aes(x = times, y = data_list[[5]], color = as.factor(percentiles[5])), size = 1) +\n    scale_color_discrete(name = \"Percentiles\")\n  \n  print(percentile_plot)\n  \n  # Plot Histograms (start vs end)\n  R <- range(c(start, population))\n  start_hist <- ggplot() + theme_minimal() + \n    geom_histogram(aes(x = start), binwidth = diff(R) / 30, fill = 'lightgreen', alpha = 0.7) + \n    labs(title = \"Start\", x = \"Wealth\", y = \"Frequency\")\n  \n  end_hist <- ggplot() + theme_minimal() + \n    geom_histogram(aes(x = population), binwidth = diff(R) / 30, fill = 'lightblue', alpha = 0.7) + \n    labs(title = \"End\", x = \"Wealth\", y = \"Frequency\")\n  \n  grid.arrange(start_hist, end_hist, ncol = 2)\n  \n  # Plot Ordered Curves\n  order <- seq_along(start)\n  start_sorted <- sort(start)\n  pop_sorted <- sort(population)\n  \n  ordered_plot <- ggplot() + theme_minimal() +\n    geom_line(aes(x = start_sorted, y = order, color = \"Start\"), size = 1) +\n    geom_line(aes(x = pop_sorted, y = order, color = \"End\"), size = 1) +\n    labs(x = \"Wealth\", y = \"Order\", title = \"Ordered Curves\") +\n    scale_color_manual(values = c(\"Start\" = \"green\", \"End\" = \"blue\")) +\n    theme(legend.title = element_blank())\n  \n  print(ordered_plot)\n}\n\n# Example usage:\n# show(population)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}